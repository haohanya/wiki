# 面试题

## 技术问题

### 静态变量和实例变量的区别

> 在语法定义上的区别：静态变量前要加 static 关键字，而实例变量前则不加。
>
> 在程序运行时的区别：静态变量则可以直接使用类名来引用。静态变量不属于某个实例对象，而是属于类，所以也称为类变量，只要程序加载了类的字节码，不用创建任何实例对象，静态变量就会被分配空间，静态变量就可以被使用了。且一个类不管创建多少个对象，静态变量在内存中有且仅有一个拷贝。在 Java 开发中，上下文类和工具类中通常会有大量的静态成员。
>
> 实例变量属于某个对象的属性，必须创建了实例对象，其中的实例变量才会被分配空间，才能使用这个实例变量。

### 分布式事务

> 事务分为本地事务和分布式事务，在以往我们的项目还是部署在单点的时候，采用本地事务即可解决，但是一旦将模块拆分开后，本地事务就没办法满足我们的需求，这时候就需要采用分布式事务

#### CAP理论：

> 分布式它有一个CAP理论，其中C表示一致性、A表示可用性、P表示分区容错性，这三个指标在分布式事务中没办法做到全部满足
>
> 分区容错：大多数分布式系统都会有很多个子网络每一个子网络又称之为一个区，分区容错的意思就是区间通信可能会失败
>
> 可用性：可用性表示用户如果发送请求，服务器必须响应
>
> 一致性：用户在执行写操作后，必须返回该值，

#### BASE理论：

> BASE理论分表为：BA基本可用、S软状态、E最终一致性。
>
> BASE理论是针对CAP理论中的一致性和可用性权衡的结果。它的核心思想就是不采用强一致性，而是根据业务自身的特点将数据做到最终一致性

#### 分布式事务的解决方案：

> 1、两段提交方式：
>
> 2、TCC补偿机制
>
> 3、消息最终一致性

#### TCC补偿机制

> TCC补偿机制的核心思想是将每个操作都注册一个确认和补偿的机制
>
> 其中TCC分为三个阶段，分别是：
> 
> Try阶段：转账操作将A和B的账户冻结起来
>
> Confirm阶段：进行转账业务的操作
>
> Cancel阶段：如果第二步执行成功的话，那么久提交事务，如果执行失败则调用解冻的方法

#### 消息最终一致性

> 消息最终一致性的核心思想是将分布式事务拆分为本地事务，这也是用的比较多的一种方案,这种方案需要一个中间表来实现

实现思路

> 当服务发生异常的时候，向MQ中发送一条消息，消息为要回退的数据
> 
> 消费者从MQ中提取消息，保存到中间表中,然后定时去中间表中读取数据并回滚

###  谈谈对Spring Ioc和AOP的理解

> Ioc和AOP是spring框架的核心概念
>
> Ioc：Ioc是控制反转也称之为依赖注入（DI），如果A类需要调用B类，以前我们都是在A类中new一个对象来调用，而现在我们吧new对象这一步交给spring的ioc处理，在调用的时候容器会帮我们实例化，ioc实现方式有两种，第一种是通过xml 方式来创建，第二种采用注解方式，在spring5中推荐我们使用注解方式
>
> AOP：在我们的应用程序中，通常会做一些和业务无关的事情，比如记录日志，事务提交等，如果我们吧这些代码写在业务中，会照成耦合性较高，这时候我们可以使用AOP来解决这个问题。Spring AOP也称之为面向切面编程，它是OOP的一个延续，它是基于动态代理的方式实现消息的截取并对消息经行一系列的装饰从而取代原有对象的执行，spring有两种创建aop的方式，第一种是基于jdk动态代理的方式，这种方式的代理类必须有接口才能实现，第二种方式是基于cglib方式，它不需要接口就可以实现，在spring AOP中有很多的技术名词，比如target(目标类:需要被代理的类)、Joinpoint(连接点:被拦截到的方法)、PointCut(切入点:已经被增强的连接点)、advice(通知/增强:例如：after、before )、Weaving(织入:是指把增强advice应用到目标对象target来创建新的代理对象proxy的过程)、proxy(代理类)、Aspect(切面:是切入点pointcut和通知advice的结合)

### SpringMVC的执行原理

> 用户发送请求到DispatcherServlet
>
> DispatcherServlet去执行HandleMapping获取到最终要执行的Handler后返回给DispatcherServlet，
>
> DispatcherServlet请求HandleAdatper执行Handler后得到一个MandelAndView返回给DispatcherServlet
>
> DispatcherServlet请求视图解析器后得到一个视图后返回给DispatcherServlet
>
> DispatcherServlet渲染视图后响应给用户 
>

### SpringMVC常用注解

> @RequestMapping
>
> @ResponseBody
>
> @GetMapping
>
> @PostMapping
>
> @PutMapping
>
> @DeleteMapping
>
> @RestController
>
> @Controller
>
> @RequestParam

### Redis中的数据类型有哪些，应用场景有哪些

### Redis缓存穿透、缓存击穿、缓存雪崩问题及解决方案

#### 缓存穿透

> 缓存穿透出现的可能原因是用户查询的数据在数据库和缓存中都没有数据，而用户不断的发起那个请求，也会不断的请求数据库，从而导致数据库压力过大，这时我们可以在接口层对参数的校验以及用户的鉴权，如果还是通过了校验，我们可以把查到的空数据写入到Redis中，这样下一次查询Redis中就不会为空

#### 缓存击穿 

> 缓存击穿出现的原因可能是在数据库中有数据，但是在Redis中没有数据，这时出现了大量的用户访问接口，就会导致没有及时的将数据存入到Redis从而访问数据库，这时我们可以使用缓存预热来解决缓存击穿

#### 缓存雪崩 

> 缓存雪崩出现的原因可能是Redis中的大批量数据在同一时间过期，而查询数据量巨大，导致数据库压力过大甚至宕机，我们可以将数据设置一个随机到期时间，避免大批量过期。

### Redis哨兵模式

> 在主从复制中，主Redis服务器宕机后，我们需要手动去把一台服务器更换为主服务器，这里需要人工干预，非常的麻烦，还会照成短时间内不可用，这时候我们为了解决这个问题，我们会采用哨兵模式
> 
> 哨兵模式是通过定时发送指令，让Redis返回服务器的状态，当检测到主服务器宕机后从服务器会自动的变为主服务器，然后通过发布订阅模式通知其他服务器切换主机

### GET和POST的请求有什么区别

> GET一般我们用来做数据的查询操作，它的参数在url中，所以安全性较差，并且在传输过程中有长度限制，但是在刷新过程中不会受影响，可以将内容缓存
>
> POST我们用来做数据的添加操作，它的参数不会显示在url中，相对安全，在传输过程中理论没有长度限制

### Session和Cookie的区别

> Session是存储在服务器内存中，当访问量增多后，会占用服务器的性能，我们一般将重要的信息存储在session中
>
> Cookie存储在客户端本地，可以被用户禁用和修改，不安全，只能存储少量的字符串数据，因为存储在本地所以对服务器压力较小

### 接口和抽象类的区别

> 抽象类使用abstract修饰，接口需要使用interface修饰
> 
> 抽象类可以有普通成员变量，接口只能有静态常量
>
> 抽象类可以有非抽象方法，接口在1.8之后可以使用default定义非抽象方法
>
> 抽象类的抽象方法必须使用abstract修饰，接口默认为public abstract 
> 
> 抽象类可以有静态方法，接口不行
>
> 抽象类方法的作用域 除了private都可以使用，接口只能是public
> 
> 一个类可以实现多个接口，但是只能继承一个抽象类
> 
> 接口一般用来定义系统的架构，而抽象类我们一般用来写一些可以复用的代码
>

### String、StringBuilder、StringBuffer的区别

> 
> 在运行速度上面是：StringBuilder--> StringBuffer--> String
> 
> String是字符串常量，是不可修改的，而StringBuilder和StringBuffer是字符串变量，是可以修改的，
>
> 在线程安全上面：StringBuffer是线程安全的，因为StringBuffer的方法内置了许多的synchronized关键字，所以可以保证线程安全
>

### HashMap底层原理

> > HashMap是基于Map接口实现的K，V集合，底层是基于数组加链表的方式实现的，在jdk1.8之后加入了红黑树，它的扩容机制是当容量达到17时，自动当前容量 * 2，当链表长度达到8的时候会自动转化成红黑树
>
> HashMap底层就是一个数组结构，数组中的每一项又是一个链表。
>
> 新建一个HashMap的时候，就会初始化一个数组，Entry就是数组中的元素，每个Entry里面又是一个key-value的键值对，它持有一个指向下一个元素的引用，这就构成了链表。
>
> HashMap底层采用一个Entry数组来保存所有的key-value键值对
>
> 当要存储一个entry对象时，会根据hash算法来决定在数组中的位置，在根据equals方法决定它在数组位置上的链表中存储位置；
>
> 当要取出一个Entry对象时，也会根据Hash算法找到其在数组中的存储位置，再根据equals方法从该位置上的链表中取出Entry；

### ArrayList和LinkList的区别

> ArrayList相当于动态数组，它是有序的，LinkList是双向链表，是无序的，其中他们都实现了List接口，在查询操作ArrayList的效率要高于LinkList，因为LinkList是线性的存储方式，所以需要移动指针依次查找，在删除操作LinkList效率要高于ArrayList，因为ArrayList是有序的所以在删除时需要将数据向前移动

### HashMap和HashTable的区别

> 线程安全：HashTable是线程安全的，因为方法内置了synchronized关键字，
>
> null值：HashTable的k是不允许为null的
>
> 集成结构：HashMap实现了Map接口，而HashTable实现了Map接口和继承了Dictionary
>
> 初始容量与扩容：HashMap的初始容量是16，而HashTable是11，两个的填充因子都是0.75，HashMap扩容是容量 * 2，而HashTable是当前容量 * 2 + 1

### 什么是索引

> 索引相当于书籍的目录，可以快速查找到所需要的内容，MySql索引的建立对于mysql高效运行很重要，索引可以大大提高mysql的检索速度
> 
> 索引分为：单列索引和组合索引，其中单列索引只包含一个列，一个表可以有多个单列索引，但不是组合索引，组合索引是一个索引包含多个列
> 
> 在创建索引的时候，应该确保索引运用在sql的where语句
  
### 索引有哪些类型

> 主键索引：它是一个唯一的，不能为空的索引
>
> 唯一索引：它是唯一的，可以有一个为空
>
> FullText：全文索引，目前只有MyISAM引擎支持，目前只有char，varchar，text支持全文索引，它解决了在模糊查询时效率低下的问题
> 
> Hash：它是一个唯一的索引，类似于键值对的形式，它可以一次定位，不需要依次查找，所以效率很高，但是只能在=和in的条件下高效
>
> BTree：它是mysql默认的一种索引，根据一定的算法，将数据存入到二叉树中，每次查询都是从root开始，依次遍历node查询
>
> RTree：空间索引，它在mysql中很少使用，仅支持geometry（几何）数据类型
>
  
### 如何创建索引

> 可以在`create table`、`alter table`、`create index`时创建索引
  
### 谈谈对mysql优化的理解

> mysql优化应该从这几个角度出发
>
> **索引：**在做条件查询的时候我们应该在条件列加入索引
>
> 在做模糊查询的时候，我们应该考虑是否使用搜索引擎来解决
>
> **sql语句：**我们应该避免使用全表扫描，应该指定字段，例如：select *，避免使用不等于
>
> **代码：**我们应该采用一个优秀的连接池，来管理和数据库的连接
>
> **读写分离：**存储引擎有自己的特点，我们应该合理的使用到他们，读的操作可以使用MyISAM引擎，它查询速度比较高，
>
> 写的操作我们可以使用innodb存储引擎，它支持事务以及行锁等，可以保证数据的一致性
>
> **数据分片：**在mysql单表数据超过五百万条的时候，性能会极具下降，如果数据太大，应该采取分片

### MySQL中的SQL语句优化

1、不使用子查询

>
> 在5.5版本之前它是先执行外层的查询再执行里面的查询，然后将两次查询的结果进行条件筛选得到最终的结果，这样性能比较低
>
> 但是在5.6之后它会将子查询转化为表连接的方式查询
>

2、避免函数索引

> 
> 在mysql中是不支持函数索引的，所以在查询的时候避免使用函数索引
> 
> 比如说，今天的数据，那就是where date=date()这里的条件参数应该改为具体的值进行比较

3、用in来代替or

4、like双百分号无法使用索引

> 如果在模糊查询的时候前面加了百分号那么索引将会失效

5、避免向客户端发送大量数据

> 在做查询的时候，我们应该采用分页查询

6、避免数据类型不一致

7、在插入多条数据时，应该采用批量插入，而不是单条插入执行多次

8、在查询语句的字段中，不应该采用*表示，应该使用具体的字段名

### MySQL的SQL语句的执行顺序

> (1)from 
>
> (2) on 
>
> (3) join 
>
> (4) where 
>
> (5)group by(开始使用select中的别名，后面的语句中都可以使用)
>
> (6) avg,sum.... 聚合函数
>
> (7)having 
>
> (8) select 
>
> (9) order by 
>
> (10) limit

### MySQL的乐观锁和悲观锁

> 悲观锁的特点是先获取锁，在进行业务操作，即悲观的认为锁很有可能获取失败，因此要保证获取锁成功后再进行业务操作。通常来讲悲观锁需要数据库本身的支持，通常使用select...for update操作实现悲观锁，当在执行select for update时，会获取到select所查询行的行锁，如果其他并发执行的select for update试图操作同一行时，需要等待上一个锁释放，因此达到锁的效果，select for update锁会在事务结束时自动释放，因此需要在事务中才能使用
>
> 乐观锁的特点是先进行业务操作，再去拿锁，即乐观的认为拿锁多半是会成功的，因此在最后实际更新业务时再去拿锁，乐观锁是靠逻辑实现的，不需要数据库的特殊支持，一般的做法是在行上加入版本号或者时间戳

### JVM的理解

> jvm有三个代，其中有年轻代，年老代，持久代
>
> 其中年轻代分为三个区，分别是一个Eden区和两个Survivor区，大部分对象都在Eden区，其中Eden区满后，还存活的对象将会被复制倒一个Survivor（幸存区）中，当一个Survivor满后将存活的对象复制到另一个Survivor中，当另一个Survivor满后，会将存活的对象复制倒年老去
>
> 所以年老代是存放年轻代存活的对象，一般来说年老代的对象生命周期会比较长

### JVM的垃圾回收

> 标记-清除算法
>
> 标记清除算法分为两个阶段，分别是标记和清除阶段，标记阶段就是标记出所有需要清除的对象，清除阶段就是清除有标记的对象所占用的空间，这种方法会很容易产生内存碎片，碎片太多，在后面为对象创建空间时可能没有空间而提前触发垃圾回收动作
>
> 复制算法
>
> 复制算法是将可用的内存空间分为两份，其中只使用一份，当一份空间用完后，将存活的对象复制倒另一个内存空间中，然后一次清除掉上一份空间的内存，这样就不会产生内存碎片，这种虽然解决了碎片的问题，但是对内存要求非常大，因为要将内存分为两半，所以可用内存空间只有原有的一半
>
> 标记-整理算法
>
> 这个算法的标记阶段和标记清除算法一样的，但是在标记完成后，并没有直接的清除可回收对象，而是将存活对象向一端移动，然后清理掉另一端的内存
>
> 分代回收算法
>
> 分代回收算法大部分jvm的垃圾收集器采用的算法，它的核心思想是根据对象声明周期的不同，将内存划分为几块，根据每块内存区间的特点，使用不同的垃圾回收算法

### Tomcat调优

> 1、将tomcat的运行模式切换为nio，因为tomcat默认是以nio模式运行，性能低下，nio是基于缓冲区并能提供非阻塞io操作的api
>
> 2、开启线程池，在tomcat中每一个用户请求都是一个线程，所以可以使用线程池提高性能。
>
> 3、禁用jap连接器，我们一般是使用Nginx+tomcat的架构，所以用不着AJP协议，所以把AJP连接器禁用
>
> 4、JVM参数优化

### Java的多线程同步

> 方法或者代码块同步使用synchronized关键字

### 线程有几种实现方式

> 继承Thread类重写run方法和实现Runnable接口
>

### 线程如何使用

> 集成Thread类；实现runnable接口；实现Callable接口重写call方法（这个其实就是帮我们封装了runnable接口）；
>
> 在使用runnable的时候，外面要包一层new Thread
>
> new Thread(new Thread02("张三").start())
>

### start和run的区别

> 调用start后会依次执行run方法开启多个线程，而调用run后并不会启动多线程，而是单个线程在执行

### Sleep ()和 wait ()之间有什么区别

> 这两个方法来自不同的类，分别的Thread和Object
>
> Sleep他没有释放锁，而wait方法释放了锁
>
> sleep必须捕获异常，而wait不需要
>
> sleep是Thread类的静态方法，sleep的作用是让线程休眠，到时间恢复
>
> wait是Object的方法，也就是说可以对任意一个对象调用wait方法，调用wait方法会将调用者的线程挂起

### 什么是死锁

> 死锁就是多个线程在运行过程中抢夺资源而造成的一种僵局，当线程处于这种僵局状态，如果没有外力的作用，他们都无法再向前推进

### 线程池有几种实现方式

> java中创建线程池的方式有两种
>
> 第一种是通过Executors工厂方法创建
>
> 第二种是通过`new ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue<Runnable> workQueue)自定义创建`

### 事务的ACID特性、隔离级别

> 特性：
>
> ​	**原子性**
>
> ​		一个事务必须是一个不可分割的单元，整个事务中，要么都成功要么都不成功，不可能只成功一部分
>
> ​	**一致性**
>
> ​		在进行转账操作的时候，a向b转账，但是中途中系统崩了，这时事务没有提交，所以事务中修改的数据不会提交，所以保证一致性
>
> ​	**隔离性**
>
> ​		在事务提交之前，不允许将一个事务中的数据共享给另一个事务，即在提价之前，它的结果不应该显示给其他事务
>
> ​	**持久性**
>
> ​		一旦事务提交，他会永久的保存在数据库中，即使系统崩溃修改的数据也不会丢失
>
> 
>
> 隔离级别
>
> 数据库的事务隔离级别有四种，由低到高为：`Read uncommitted`、`Read committed`、`Repeatable read`、`Serializable`，在并发中，可能会出现脏读，不可重复读，幻读
>
> **Read uncommitted**
>
> ​	读未提交：一个事务可以读另一个事务未提交的数据
>
> ​		事例：老板要给程序员发工资，程序员的工资为1.8万，但是老板在发工资时，多发了2千，这个钱已经打到程序员的账户中，但是事务还没有提交，就在这时，程序员去查看了自己的工资，发现比以往多了2千，以为涨工资了非常高兴，但是老板发现不对，马上回滚了事务，将2万改为了1.8万再提交
>
> ​		分析：实际程序员工资是1.8万，但程序员看到的是2万，他看到的是老板还没有提交事务之前的数据，这就是`脏读`
>
> **Read committed**
>
> ​	读提交：一个事务要等另一个事务提交之后才能读取数据
>
> ​	事例：程序员拿着余额有3万的信用卡去享受生活，当他买单时，程序员事务开启了，收费系统事先检查他卡里有3万元，就在这个时候，程序员老婆把全部的钱转出充当家用，并提交，当收费系统扣款时，再检测卡里余额时，发现已经没有钱了，程序员郁闷了...
>
> ​	分析：如果有事务对数据进行更新操作时，读操作事务要等待这个更新操作的事务提交后才能读取数据，可以解决脏读的问题，但这个事例中，出现了一个事务内两个相同的查询出现了不同的数据，这就是`不可复读`
>
> **Repeatable read**
>
> ​	重复读：在事务开启时，不再允许修改操作
>
> ​	事例：程序员拿着3万元的信用卡去享受生活，当他买单时，程序员事务开启了，收费系统检测到他卡里有3万元，这时候程序员老婆就无法将余额转出，接下来收费系统就可以扣款了，
>
> ​	分析：重复读可以解决不可重复读的问题，不可重复读对应的是修改，但是可能会出现`幻读`，因为幻读操作对应的是新增操作
>
> **什么时候会出现幻读？**
>
> ​	事例：程序员某一天买了一个键盘花了2千元，然后他的老婆去查询他今天的消费记录，老婆事务开启，然后发现确实是消费了2千元，就在这时，程序员又花了1万元买了台电脑，即新增一条消费记录并提交，他老婆打印出消费单时，事务提交，发现花费了1.2万元，似乎出现了幻觉，这就是`幻读`
>
> **Serializable序列化**
>
> Serializable 是最高的事务隔离级别，在该级别下，事务串行化顺序执行，可以避免脏读，不可重复读和幻读，但是这种级别效率低下，比较消耗性能，一般不使用

### 基本数据类型和引用数据类型区别

> 基本数据类型包括数字型，字符型，布尔型，数字型包括整形和浮点型，基本数据类型它的值不可改 变，它存在栈里面，而引用类型它包括类、接口、数组它们的值可以改变，因为有属性和方法 

### Redis和数据库怎么保持一致

### 联合索引和普通索引有什么区别

### 什么情况下做索引

### 为什么重写equals和HashCode

> 当我们有两个对象做比较的时候，我们可以使用对象中具体的属性比较，但是如果比较的属性很多的话，就会写很多的重复性代码，如果我们重写了equals就可以直接进行对象比较里面的属性
>
> 重写HashCode是为了在一些算法中，避免发生冲突和碰撞
>

### 深克隆和浅克隆有什么区别

### 创建一个对象还有什么方法

> 通过反射机制，首先我们获取到对象的class，获取方法有.class和getClass
>
> 获取到class后通过newInstance()方法创建对象
>

### Redis淘汰策略

> noevication：不删除策略，达到最大内存限制时，如果需要更多内存，则直接返回错误信息。 
>
> allkeys-lru：所有key通用，优先删除最近最少使用的key
>
> volatile-lru：只限于设置了expire的部分，优先删除最近最少使用的key
>
> allkeys-random：所有key通用，随机删除一部分key
>
> volatile-random：只限于设置了expire的部分，随机删除一部分key
>
> volatile-ttl：只限于设置了expire的部分，优先删除剩余时间短的key

### MQ消息丢失怎么办

> 消息百分百发送成功的方案：
>
> 消息生产者将业务数据写入数据库后发送一条消息到Q1然后再发送一条延迟消息到Q3
>
> 消息消费者监听到Q1的消息后向Q2发送一条确认消息
>
> 在回调检查服务中监听Q2和Q3的消息，并写入数据库
>
> 然后有一个定时检查服务，检查两个数据库之间的消息是否一致，如果不一致则从新发送消息

### mysql查重

> mysql查重可以采用聚合函数中的count来实现
>
> 其中条件为count(name) > 1
>
> DELETE FROM tb_info WHERE id in(
> 	SELECT id FROM tb_info GROUP BY `name` HAVING  COUNT(`name`) > 1
> )

### char和varchar的区别

> char的长度是固定的，而varchar长度是可变的，
>
> 如果char插入的值的长度小于char的长度，那么它所占用的内存为char 的长度
>
> 而varchar插入的值的长度是多少就是多少
>
> char的效率要比varchar的效率稍高一点
>

### char和varchar的长度超出会出现什么

> 低版本会截取，高版本会报错

### 一张表的数据移动到另一张表如何操作
   
> CREATE TABLE test1(
>
> 	SELECT * FROM tb_info
>
> );

### JAVA8的新特性

> **Lambda 表达式** − Lambda 允许把函数作为一个方法的参数（函数作为参数传递到方法中）。
>
> **方法引用** − 方法引用提供了非常有用的语法，可以直接引用已有Java类或对象（实例）的方法或构造器。与lambda联合使用，方法引用可以使语言的构造更紧凑简洁，减少冗余代码。
>
> **默认方法** − 默认方法就是一个在接口里面有了一个实现的方法。
>
> **新工具** − 新的编译工具，如：Nashorn引擎 jjs、 类依赖分析器jdeps。
>
> **Stream API** −新添加的Stream API（java.util.stream） 把真正的函数式编程风格引入到Java中。
>
> **Date Time API** − 加强对日期与时间的处理。
>
> **Optional 类** − Optional 类已经成为 Java 8 类库的一部分，用来解决空指针异常。
>
> **Nashorn, JavaScript 引擎** − Java 8提供了一个新的Nashorn javascript引擎，它允许我们在JVM上运行特定的javascript应用。

### JAVA8和JAVA7的JVM内存模型有什么区别

> java8之后将永久带给删除了，使用了元空间替代
>

### 永久带在哪里

> 方法区
>

### 数据库的ACID（事务）

> 原子性：一个不可分割的工作单元，事务中的操作，要么都发生，要么都不发生
>
> 一致性：事务开始之前和事务结束之后，数据库的完整性约束没有被破坏
>
> 隔离性：多个事务同时进行时，事务和事务之间是隔离的，一个事务不会影响其他事物的运行
>
> 持久性：当事务执行完成以后，该事物对数据库操作所更改的数据将持久的保存在数据库中，并不会回滚
>

### 多个线程修改数据，怎么保证数据一致性

> 这里采用了`乐观锁`，乐观锁其意思就是在表中添加一个版本号，每次操作数据都需要去比对版本号，当数据更新后版本号+1，后续的操作如果版本号不匹配则拒绝操作
>

### JAVA原子性怎么理解的

> 原子性是一个操作不能被打断，要么全部执行，要么不执行，例如：a = 1这就是原子性，而a++，a+=1就不是原子性
>

### JAVA加锁的方法有哪些

> `synchronized`关键字
>
> `Java.util.concurrent`包中的`lock`接口和`ReentrantLock`实现类
>
> synchronized是java语言内置的一款锁，而lock是一个类，两者有一个非常大的不同就是，synchronized是自动释放锁，而lock需要手动取释放，当synchronized修饰的代码块执行完后自动释放，lock则需要我们手动去释放锁，如果没有主动释放锁，则会照成死锁现象，lock可以让等待锁的线程中断，而synchronized不行，使用synchronized的时候等待线程会一直等待下去，不能响应中断

### spring创建对象默认是什么模式

> r默认是单例模式，也可以去指定其他的模式，例如：工厂
>

### 实现多线程的方式

> 1.继承Thread类r，重写run方法
> 2.实现Runnable接口，重写run方法，实现Runnable接口的实现类的实例对象作为Thread构造函数的target
> 3.通过Callable和FutureTask创建线程
> 4.通过线程池创建线程
>

### 线程池的作用

> 利用线程池管理并复用线程、控制最大并发数等。
>
> 实现任务线程队列缓存策略和拒绝机制。
>
> 实现某些与时间相关的功能，如定时执行、周期执行等。
>
> 隔离线程环境。比如，交易服务和搜索服务在同一台服务器上，分别开启两个线程池，交易线程的资源消耗明显要大；因此，通过配置独立的线程池，将较慢的交易服务与搜索服务隔开，避免个服务线程互相影响。

### post和get请求

> get请求它会在url中显示的展示出来，而post它看不到提交的数据，get请求长度受限，post请求理论上无限制数据大小

### maven仓库介绍下

> Maven 仓库是项目中依赖的第三方库，这个库所在的位置叫做仓库。
>
> Maven 仓库有三种类型：
>
> - 本地（local）
> - 中央（central）
> - 远程（remote）

### maven版本的意义

> 版本迭代中会存在接口的变动，如果不定义版本的话，会出现现在使用的接口没有，或者变动，就会出现代码出错

13、dubbo底层调用方式

> 1、服务提供者启动
>
> 2、启动后将服务注册进注册中心
>
> 3、服务消费者在启动时订阅自己需要的服务提供者
>
> 4、注册中心返回服务提供者给服务消费者
>
> 5、服务消费者从提供者列表中基于负载均衡算法选一台调用，如果调用失败在选另一台
>
> 6、服务提供者和消费者定时发送心跳到数据监控中心

### 动静分离好处（前后端分离）

> 前后端分离好处：前端人员不需要涉及到后端的技术，而后端人员只需要提供一个接口，不需要涉及到前端技术，前后端技术应该让专业人员开发，并且在后端开发的时候前端也可以同步开发。

### ajax同步和异步有什么区别

> 同步请求就是在请求的时候页面没办法去做其他事情，而异步请求页面可以去做其他事情，也可以做到无刷新


垃圾回收的算法有哪里？优缺点是什么

> 标记清除算法
>
> 标记清除算法分为两个阶段，分别是标记阶段和清除阶段，其中标记阶段就是标记出所需要清除的对象，清除阶段就是清除标记阶段标记的对象
>
> 这个算法容易出现垃圾碎片，如果垃圾碎片过多，就会提前触发垃圾回收操作
>
> 复制算法
>
> 复制算法就是将内存空间分为两部分，当触发回收后，会将存活的对象复制到另一半内存中，然后将之前的一半给清除掉，这种算法解决了垃圾碎片过多的问题，但是只能使用一半的内存，对内存要求较大
>
> 标记整理算法
>
> 这个算法的标记阶段和标记清除算法一样，在标记完成之后并不会立刻清除对象，而是将存活的对象移动到另一端，然后再清除
>
> 分代回收算法
>
> 这个算法在jvm中大量的使用，它的核心就是将对象分为不同的生命周期，将内存划分为几块，根据每个内存空间不同的特点，使用不同的回收算法
>
> 其中分为年轻代，年老代，持久代
>
> 其中年轻代分为三个区，Eden区和两个幸存区，大部分的对象都在幸存区，当幸存区满了之后，会触发一次垃圾回收，将存活的对象复制到第一个幸存区中，然后将eden区的对象删除，当第一个幸存区满后，会将存活的对象复制到第二个幸存区中，然后清除第一个幸存区，当第二个幸存区也满后，会将存活的对象放入到年老代

### 什么是SpringCloud

> Spring Cloud可以理解为一个工具箱，它提供了各类工具，可以快速构建微服务系统。

### SpringCloud熔断器（断路器）是什么

> 因为SpringCloud是基于Rest风格调用的，http有一个很大的缺点，就是如果发生异常，会长时间无法响应，如果使用了熔断器，那么我们可以设置一个超时时间，如果超时，那么就返回一个错误的信息，而不是长时间的等待

### SpringCloud的核心组件有哪些

> Eureka：它给我们提供了服务的注册与发现
>
> Fegin：基于动态代理机制，根据注解和选择机器，拼接URL发起请求
>
> Ribbon：实现负载均衡，从多台服务器之间选择一个服务调用
>
> Hystrix：提供线程池，不同的服务走不同的线程池，实现了服务的隔离，避免雪崩问题
>
> Gateway：网关管理，由它来实现服务的转发

### SpringCloud和Dubbo的区别

> SpringCloud是Apache旗下的Spring体系的微服务解决方案
>
> Dubbo是国产阿里巴巴公司开源的一个服务治理框架
>
> SpringCloud是一个基于Http Rest方式调用
>
> 而Dubbo是基于RPC方式调用，当当网开源的Dubbox新增了Http Rest方式
>
> Dubbo仅仅实现了服务治理模块，而SpringCloud现在已经有20多个组件

### 微服务之间是如何独立通讯的

> 远程调用方式：
>
> ​	也就是常用的服务的注册与发现
>
> ​	优点：简单，常用，没有中间件，系统简单
>
> ​	缺点：不支持异步请求
>
> 消息中间件：
>
> ​	使用异步消息来做服务间的通讯
>
> ​	优点：解耦，提高可用性，支持异步操作
>
> ​	缺点：加入了中间件，增加了系统的复杂度

### 负载均衡的意义是什么

> 当我们相同的模块部署在多台服务器的时候，如果不使用负载均衡，就只能调用一台服务器的服务，而使用了负载均衡后，可以采用轮询算法，挨个调用服务

### SpringCloud如何实现服务的注册?

> 1、服务启动的时候，将服务注册到Eureka中
>
> 2、服务调用的时候使用@EnableDiscoveryClient注解，然后使用Ribbon或者Feign进行服务调用

### 什么是服务熔断？什么是服务降级？

> 在复杂的分布式系统中，微服务之间的相互掉哦那个，有可能出现各种原因导致服务的阻塞，在高并发的场景下，服务的阻塞意味着线程的阻塞，导致当前线程不可用，服务器的线程全部阻塞会导致服务器崩溃，由于服务之间的调用关系是同步的，会对整个微服务系统照成服务雪崩
>
> 为了解决雪崩问题，就需要加入服务熔断和服务降级处理

###  Eureka和ZooKeeper都可以提供服务注册与发现的功能,请说说两个的区别

> ZooKeeper有领导者和追随者角色,Eureka各个节点平等
>
> ZooKeeper采用过半数存活原则,Eureka采用自我保护机制解决分区问题
>
> Eureka本质上是一个工程,而ZooKeeper只是一个进程

### Eureka自我保护机制是什么?

>当Eureka的服务节点在短时间内丢失了过多实例的连接后会开启自我保护模式，保护注册信息，不再删除注册数据，当故障恢复后，则会关闭自我保护模式

### 什么是Ribbon？

> Ribbon是一个负载均衡器，Feign内置集成了Ribbon

### 什么是feigin？它的优点是什么？

> Feign采用SpringMVC的注解
>
> Feign集成了Ribbon，具有负载均衡的能力
>
> 整合了Hystrix，具有熔断的能力

### Ribbon和Feign的区别？

> 启动注解不同，Ribbon是@RibbonClient，feign的是@EnableFeignClients
>
> 调用方式不同，Ribbon需要自己构建http请求，模拟http请求然后使用HttpTemplate发送给其他服务；
>
> Feign只需要将调用的方法定义为接口即可

### RabbitMQ的流程

> 生产者创建一个连接到RabbitMQ开启一个信道
>
> 生产者声明一个交换器，并设置相关属性，比如交换机类型、是否持久化等
>
> 生产者声明一个队列井设置相关属性，比如是否排他、是否持久化、是否自动删除等
>
> 生产者通过路由键将交换器和队列绑定起来
>
> 生产者发送消息至RabbitMQ Broker，其中包含路由键、交换器等信息
>
> 相应的交换器根据接收到的路由键查找相匹配的队列。
>
> 如果找到，则将从生产者发送过来的消息存入相应的队列中。
>
> 如果没有找到，则根据生产者配置的属性选择丢弃还是回退给生产者
>
> 关闭信道。
>
> 关闭连接。

## 非技术问题

### 上家公司叫什么

### 公司是干什么的

### 公司规模

### 项目的周期

### 研发人员的团队有多少

### 项目进度的把控

### 项目遇到的困难

### 项目是否上线

### Linux上怎么部署项目

### 在之前公司担任的职位(说说在上一个公司的工作内容)

### 公司主要运营什么样的产品

### 薪资期望

### 加班看法

### 是否接受出差
